'-------------- Device Params -----------------------
Params
FB1.PIN = 100
FB1.POUT = 20
FB1.PUNIT = 0
FB1.SELECT = -1
FB2.PIN = 100
FB2.POUT = 20
FB2.PUNIT = 0
FB3.PIN = 100
FB3.POUT = 20
FB3.PUNIT = 0
UNIT.ACCLINEAR = 0
UNIT.ACCROTARY = 0
UNIT.LABEL = "cm"
UNIT.PIN = 1
UNIT.PLINEAR = 0
UNIT.POUT = 1
UNIT.PROTARY = 4
UNIT.VLINEAR = 0
UNIT.VROTARY = 0 ' 0 = rpm, 1 = rps, 2 = deg/s, 3 = custom, 4= rad/s, I want 0 (RPM)
AIN.CUTOFF = 5000.0
AIN.DEADBAND = 0.000
AIN.DEADBANDMODE = 0
AIN.ISCALE = 0.001
AIN.MODE = 1
AIN.OFFSET = 0.000
AIN.PSCALE = 0.000
AIN.VSCALE = 0.06
AOUT.DEBUGADDR = 4
AOUT.DEBUGDATATYPE = 0
AOUT.DEBUGSCALE = 1.0
AOUT.ISCALE = 0.001
AOUT.MODE = 0
AOUT.OFFSET = 0.000
AOUT.PSCALE = 0.000
AOUT.VSCALE = 0.06
CAP0.EDGE = 1
CAP0.EN = 0
CAP0.EVENT = 0
CAP0.FILTER = 0
CAP0.MODE = 0
CAP0.PREEDGE = 1
CAP0.PREFILTER = 0
CAP0.PRESELECT = 0
CAP0.TRIGGER = 0
CAP1.EDGE = 1
CAP1.EN = 0
CAP1.EVENT = 0
CAP1.FILTER = 0
CAP1.MODE = 0
CAP1.PREEDGE = 1
CAP1.PREFILTER = 0
CAP1.PRESELECT = 0
CAP1.TRIGGER = 0
CS.DEC = 10000.17
CS.TO = 6
CS.VTHRESH = 5.0
DIN1.FILTER = 1
DIN1.INV = 0
DIN1.MODE = 0
DIN2.FILTER = 1
DIN2.INV = 0
DIN2.MODE = 0
DIN3.FILTER = 2
DIN3.INV = 0
DIN3.MODE = 0
DIN4.FILTER = 2
DIN4.INV = 0
DIN4.MODE = 0
DIN5.FILTER = 2
DIN5.INV = 0
DIN5.MODE = 0
DIN6.FILTER = 2
DIN6.INV = 0
DIN6.MODE = 0
DIN7.FILTER = 2
DIN7.INV = 0
DIN7.MODE = 0
DIO10.DIR = 0
DIO10.INV = 0
DIO11.DIR = 0
DIO11.INV = 0
DIO9.DIR = 0
DIO9.INV = 0
DOUT.RELAYMODE = 0
DOUT1.MODE = 0
DOUT1.PARAM = 0.000
DOUT2.MODE = 0
DOUT2.PARAM = 0.000
DRV.ACC = 10000.17

' REQUIRED FOR MOVE.RUNSPEED IS DRV.OPMODE = 2 and 
' DRV.CMDSOURCE = 5, SO THIS IS IMPORTANT!!
DRV.CMDSOURCE = 5

DRV.DBILIMIT = 1.0
DRV.DEC = 10000.17
DRV.DIR = 0
DRV.DISTO = 1000
DRV.EMUEDIR = 0
DRV.EMUEMODE = 0
DRV.EMUEMTURN = 0
DRV.EMUERES = 0
DRV.EMUEZOFFSET = 0
DRV.HANDWHEELSRC = 2
DRV.NAME = "AKD_VFD"

' REQUIRED FOR MOVE.RUNSPEED IS DRV.OPMODE = 2 and 
' DRV.CMDSOURCE = 5, SO THIS IS IMPORTANT!!
DRV.OPMODE = 2

FAULT130.ACTION = 0
FAULT131.ACTION = 0
FAULT132.ACTION = 0
FAULT134.ACTION = 0
FAULT451.ACTION = 0
FAULT702.ACTION = 0
FB1.BISSBITS = 32
FB1.INITSIGNED = 1
FB1.OFFSET = 0
FB1.ORIGIN = 0
FB1.PDIR = 0
FB1.POFFSET = 0
FB1.POLES = 2
FB1.PSCALE = 20
FB2.DIR = 0
FB2.ENCRES = 0
FB2.MODE = 0
FB2.POFFSET = 0
FB2.SOURCE = 0
FB3.MODE = 0
FB3.PDIR = 0
FB3.POFFSET = 0
IL.FOLDWTHRESH = 0.000
IL.KACCFF = 1.068
IL.KP = 74.82
IL.LIMITN = -17.999
IL.LIMITP = 18.0
IL.OFFSET = 0.000
LOAD.INERTIA = 0.000
MOTOR.BRAKEIMM = 0
MOTOR.PHASE = 0
MOTOR.PITCH = 32.0
MOTOR.TBRAKETO = -1
MOTOR.TEMPWARN = 0
PL.ERRFTHRESH = 655360
PL.ERRMODE = 0
PL.ERRWTHRESH = 0
PL.FBSOURCE = 0
PL.INTINMAX = 61035
PL.INTOUTMAX = 61035
PL.KI = 0.000
PL.KP = 66.824
PL.MODP2 = 1048576
PL.MODPDIR = 0
PL.MODPEN = 0
PLS.EN = 0
PLS.MODE = 0
PLS.P1 = 0
PLS.P2 = 0
PLS.P3 = 0
PLS.P4 = 0
PLS.P5 = 0
PLS.P6 = 0
PLS.P7 = 0
PLS.P8 = 0
PLS.T1 = 500
PLS.T2 = 500
PLS.T3 = 500
PLS.T4 = 500
PLS.T5 = 500
PLS.T6 = 500
PLS.T7 = 500
PLS.T8 = 500
PLS.UNITS = 0
PLS.WIDTH1 = 0
PLS.WIDTH2 = 0
PLS.WIDTH3 = 0
PLS.WIDTH4 = 0
PLS.WIDTH5 = 0
PLS.WIDTH6 = 0
PLS.WIDTH7 = 0
PLS.WIDTH8 = 0
REGEN.REXT = 330
REGEN.TEXT = 100.0
REGEN.TYPE = 0
REGEN.WATTEXT = 1000
SWLS.EN = 0
SWLS.LIMIT0 = 0
SWLS.LIMIT1 = 1048576
USER.INT1 = 0
USER.INT2 = 0
USER.INT3 = 0
USER.INT4 = 0
USER.INT5 = 0
USER.INT6 = 0
USER.INT7 = 0
USER.INT8 = 0
USER.INT9 = 0
USER.INT10 = 0
USER.INT11 = 0
USER.INT12 = 0
USER.INT13 = 0
USER.INT14 = 0
USER.INT15 = 0
USER.INT16 = 0
USER.INT17 = 0
USER.INT18 = 0
USER.INT19 = 0
USER.INT20 = 0
USER.INT21 = 0
USER.INT22 = 0
USER.INT23 = 0
USER.INT24 = 0
VBUS.OVWTHRESH = 0
VBUS.UVFTHRESH = 380
VBUS.UVMODE = 1
VBUS.UVWTHRESH = 390
VL.ARPF1 = 1689.781
VL.ARPF2 = 500.0
VL.ARPF3 = 1150.219
VL.ARPF4 = 1150.219
VL.ARPQ1 = 0.707
VL.ARPQ2 = 0.5
VL.ARPQ3 = 0.707
VL.ARPQ4 = 0.707
VL.ARTYPE1 = 5
VL.ARTYPE2 = 5
VL.ARTYPE3 = 5
VL.ARTYPE4 = 5
VL.ARZF1 = 2577.293
VL.ARZF2 = 500.0
VL.ARZF3 = 5000.0
VL.ARZF4 = 5000.0
VL.ARZQ1 = 0.707
VL.ARZQ2 = 0.5
VL.ARZQ3 = 0.707
VL.ARZQ4 = 0.707
VL.FBSOURCE = 0
VL.GENMODE = 0
VL.KBUSFF = 0.000
VL.KI = 29.966
VL.KP = 0.517
VL.KVFF = 1.0
VL.LIMITN = -2999.999
VL.LIMITP = 3000.0
VL.LMJR = 0.000
VL.THRESH = 7219.166
WS.DISTMAX = 2731
WS.DISTMIN = 182
WS.FREQ = 10.0
WS.IMAX = 9.0
WS.MODE = 0
WS.NUMLOOPS = 5
WS.T = 2
WS.TDELAY1 = 5
WS.TDELAY2 = 50
WS.TDELAY3 = 100
WS.VTHRESH = 100.0
End Params
'-------------- Define (dim) Global Variables --------

' all of these variables are mapped to user defined input 
' registers, allowing for shared data between this application
' (Fully Reversed Torsion Test.bas) and the watchdog application 
' (Twister 2015 is this case)

' An indicator as to if this test is in run mode or manual mode
' Two possible values:
'   Run mode ....... _TRUE
'   Manual mode .... _FALSE
Dim testInProcess As Integer

' An indicator that the watchdog program has set the following parameters:
' cwTorque, ccwTorque, runSpeed, manualSpeed
' Two possible values:
'   Run mode ....... _TRUE
'   Manual mode .... _FALSE
Dim controllerInitialized As Integer

' The most recent torque value provided by the watchdog application. 
' The values are in in-lbs and are used as values to start and stop 
' certain portions of the test.  SAFETY CRITICAL!! The test bench can 
' produce more torque than most tested components can handle.
' Range of possible values, based off the torque cell:
'   Minimum ...... -20,000 in-lbs
'   Maximum ...... 20,000 in-lbs
' The actual maximum values should be test dependant, for example, a 
' 1000 series steering shaft is tested to +/- 4,000 in-lbs
Dim currentTorque As Integer

' This is a frequently updated value who's purpose is to make sure 
' communication is ongoing between this application and the the watchdog 
' application.  The watchdog application (Twister 2015) resets this value 
' each time it requests a rotational position value.  This application 
' subtracts 1 from this value each time through the running test portion
' the value every time it requests a rotational position value.   
' 
' Range of possible values are set by language, integer type is 32 bit 
'   signed integer in AKD Basic language.:
'   Minimum ...... -2147483648
'   Maximum ...... 2147483647

' In practice, the Int32 maximum value is much too high to be an effective 
' watchdog value.  250 has been tested to be a good value for near instant 
' response when the watchdog application crashes or hangs.
' Range of practical values:
'   Minimum ...... 10
'   Maximum ...... 250
Dim watchdogValue As Integer

' This value is the maximimum torque value allowed in the couter-
' clockwise (CCW) direction. The counterclockwise direction when 
' looking normal to the torque cell flange face that connects to
' the test specimen (as opposed to the side connected to the 
' sliding carridge).
' Values in the CCW direction are interpreted as NEGATIVE, so 
' based off the maximum allowable torque cell torque, the limit 
' is -20,000 in-lbs.
Dim ccwTorqueLimit As Integer

' This value is the maximimum torque value allowed in the 
' clockwise (CW) direction. The clockwise direction when 
' looking normal to the torque cell flange face that connects to
' the test specimen (as opposed to the side connected to the 
' sliding carridge).
' Values in the CW direction are interpreted as POSITIVE, so 
' based off the maximum allowable torque cell torque, the limit 
' is 20,000 in-lbs.
Dim cwTorqueLimit As Integer

' This value is the maximum RPM that the electric motor should be 
' commanded to spin.  The gearbox has a 70:1 ratio, so for example 
' if the motor spins 700 rpm, the output speed to the flange of 
' the gearbox is 700 / 70 = 10 rpm, or 0.1667 rev/sec or 
' 0.1667 rev/sec * 360 deg/rev = 60 deg/s. This value will need 
' careful consideration during testing, but for now, keep the limits 
' very low, so the test is slow.
'
' Minimum Value = 10 (0.86 deg/s)
' Maximum Value = 500 (43 deg/s)
'
Dim runSpeed As Integer

' Manual speed allows the operator to use the joystick to make 
' manual adjustments to the input shaft angle while they are installing the 
' test specimen into the test stand.  This adjustment should be very 
' fine and therefore the minimum and maximum values will not have the same
' allowance for ranges, at least until the operator usage proves otherwise.
'
' Minimum Value = 5 (0.43 deg/s)
' Maximum Value = 25 (2.14 deg/s)
'
Dim manualSpeed As Integer

' This value sets the percent difference allowable between 2 consecutive
' readings from the torque cell before the part is considered to have failed
'
Dim diffLimit As Float

' This value sets the direction for the application of torque.  Acceptable 
' values are 1 and -1, any other values should cause the test
' bench to stop moving.
'
'    Clockwise direction .......... -1
'    Counterclockwise direction ...  1
'
Dim torqueDirection As Integer

' This is an ID number assigned to each type of test that is created.  Current (as of 1/15/2016)
' As more tests are added, increment values by +1
'
'   Steering Shaft Test (+/-4000 in-lbs) ...... 1
'   Unidirectional Test to Failure ............ 2
'
Dim testType As Integer

' This value allows the operator to manually complete a test, in the case 
' where they want the data saved, but cannot rely on the automated test 
' checks to save the data.  It is meant to prevent lost test data.
'
'  True ..... _TRUE  (-1)
'  False .... _FALSE (0)
'
Dim operatorEndsTest As Integer

' this section maps the variables to an input register 
' location where they can be written to and read from.
MBInfo
	$MBMap32(5000, testInProcess)
	$MBMap32(5002, controllerInitialized)
	$MBMap32(5004, currentTorque)
	$MBMap32(5006, watchdogValue)
	$MBMap32(5008, ccwTorqueLimit)
	$MBMap32(5010, cwTorqueLimit)
	$MBMap32(5012, runSpeed)
	$MBMap32(5014, manualSpeed)
	$MBMapfloat(5016, diffLimit)
	$MBMap32(5018, torqueDirection)
	$MBMap32(5020, testType)
	$MBMap32(5022, operatorEndsTest)
End

' create boolean values, since it's not supported
' by the language. 
' TRUE IS NOT A VALID NAME, SO I CHOSE _TRUE
Const _TRUE = -1 ' this is all 1s for a signed integer (32 bit signed in this case)
Const _FALSE = 0

' the torque test has two stages, clockwise and counter clockwise.
' This value indicates whether of not the first stage of the 
' test has been complete.  
' Two possible values:
'   Yes it's complete ...... _TRUE
'   No, it's incomplete .... _FALSE
Dim firstStageComplete As Integer

' This value indicates whether of not the second stage of the 
' test has been complete.  
' Two possible values:
'   Yes it's complete ...... _TRUE
'   No, it's incomplete .... _FALSE
Dim secondStageComplete As Integer

' used as a loop counter, to show how many times 
' a certain loop has executed, for debugging mainly.
Dim cnt As Integer

' used to solve the issue of having a cancelled test need 
' to stop and return to zero in the middle of a test cycle,
' usually when the user says so, or if a safety sensor 
' has been triggered.
Dim cancelled As Integer

' The last torque reading that was recorded
Dim previousTorque As Integer

'-------------- Main Program -------------------------
Main

' loop continuously
While 1 = 1
' for debugging, so I can see current values on console quickly.
'Call PrintCurrentUserParameterValues

' reset counter
cnt = 0
Call DebugMessageString(STR$(controllerInitialized))

' make sure everything is initialized before proceeding.
While (controllerInitialized = _FALSE)
print
' debugging message
If (cnt = 1) Then
Call DebugMessageString("Waiting for controller to initialize.")
ElseIf (cnt = 2) Then
Call DebugMessageString("Waiting for controller to initialize..")
ElseIf (cnt = 3) Then
Call DebugMessageString("Waiting for controller to initialize...")
Else
Call DebugMessageString("Waiting for controller to initialize")
End If

Call DebugMessageInteger("currentTorque: ", currentTorque)
' slow the loop down just a bit, no need to 
' check any faster than every 200 ms

Pause(0.2)

' increment counter
cnt = cnt + 1
If (cnt > 3) Then
cnt = 0
End If

' clear screen
Cls

' quick fix to allow manual mode before the controller is initialized
If (DIN3.STATE = 1 And testInProcess = _FALSE) Then
manualSpeed = 10
Call DebugMessageString("Waiting for joystick to move.")
Call PerformSingleManualCycle
End If
		Wend
		
		' perform validation on the user inputs, it's for their own good. 
		' this should be done each time through because at any time the 
		' watchdog application can change the values in the register. It would 
		' not be safe to assume that the user has the knowledge or controls in 
		' place to make safe parameter decisions.
		If (UserProvidedValidValues = _TRUE And controllerInitialized = _TRUE) Then
Call RunTest
End If
		
	wend
End Main

'-------------- Subroutines and Functions ------------
Sub RunTest()
    If (testType = 1) Then
        Call DebugMessageString("About to run Steering shaft test.")
        Call PerformSteeringShaftTest()
    ElseIf (testType = 2) Then
        Call DebugMessageString("About to run Unidirectional test to failure.")
        Call PerformUnidirectionalTestToFailure()
    Else
        Call PerformSingleManualCycle()
        'Exit Sub 
    End If
End Sub

'-------------------------------------------------------
' Here is the actual logic for a single 
' loop through the test cycle.
'-------------------------------------------------------
Sub PerformSteeringShaftTest()
    ' set the speed
    MOVE.RUNSPEED = runSpeed
    'MOVE.RUNSPEED = .1

    ' The testInProcess indicates that the user wants to start the test, 
    ' but the application has not yet reached the While loop below.  Once 
    ' execution reaches the While loop, it will stay there until completed.
    If (testInProcess = _TRUE) Then
        ' perform test initialization
        firstStageComplete = _FALSE
        secondStageComplete = _FALSE

        ' Home the current positon, so at the end of the test, 
        ' we can return to this position
        MOVE.POSCOMMAND = 0

        ' if the code reaches this point, the user has started a test, this 
        ' allows the Else section to call StopAnReturnToHome once.  
        cancelled = _TRUE

        Call DebugMessageString("Checking if test in process.")
        While (testInProcess = _TRUE)
            Call PerformSteeringShaftTestCycle()
		Wend
	Else
        Call DebugMessageString("Calling StopAnReturnToHome")
        If (cancelled = _TRUE) Then
            Call StopAndReturnToHome()
            cancelled = _FALSE
        End If

        ' test is not in process, so see if the user
        ' wants to enter the manual mode, based on 
        ' preset criteria.
        While (CanEnterManualMode() = _TRUE And testInProcess = _FALSE And controllerInitialized = _TRUE)
            Call DebugMessageString("Waiting for joystick to move.")
            Call PerformSingleManualCycle()
		Wend
	End If
End Sub

'-------------------------------------------------------
' Here is the actual logic for a single 
' loop through the test cycle.
'-------------------------------------------------------
Sub PerformUnidirectionalTestToFailure()
    ' set the speed
    MOVE.RUNSPEED = runSpeed

    ' The testInProcess indicates that the user wants to start the test, 
    ' but the application has not yet reached the While loop below.  Once 
    ' execution reaches the While loop, it will stay there until completed.
    If (testInProcess = _TRUE) Then
        ' perform test initialization
        firstStageComplete = _FALSE
        secondStageComplete = _FALSE

        ' Home the current positon, so at the end of the test, 
        ' we can return to this position
        MOVE.POSCOMMAND = 0

        ' if the code reaches this point, the user has started a test, this 
        ' allows the Else section to call StopAnReturnToHome once.  
        cancelled = _TRUE

        Call DebugMessageString("Checking if test in process.")

        While (testInProcess = _TRUE)
            Call DebugMessageString("About to perform single run cycle.")
            Call PerformUnidirectionalTestCycle()
		Wend
		
	Else
        Call DebugMessageString("Calling StopAnReturnToHome")
        If (cancelled = _TRUE) Then
            Call StopGently()
            cancelled = _FALSE
        End If

        ' test is not in process, so see if the user
        ' wants to enter the manual mode, based on 
        ' preset criteria.
        While (CanEnterManualMode() = _TRUE)
            Call DebugMessageString("Waiting for joystick to move.")
            Call PerformSingleManualCycle()
		Wend
	End If
End Sub

'-------------- Subroutines and Functions ------------

Sub StopGently()
    ' Do not call MOVE.ABORT, this  results in an abrupt stop and a 
    ' clunking noise from gear backlash we think.
    MOVE.RUNSPEED = 0
    MOVE.GOVEL
    MOVE.RUNSPEED = runSpeed
End Sub

Sub StopAndReturnToHome()
    Call StopGently()

    ' return to position established at the start of the test.
    MOVE.GOHOME

    ' let the test get back to zero before finishing.
    While (ABS(MOVE.POSCOMMAND) > 0)
        Call DebugMessageString("StopAndReturnToHome")
        Pause(0.1)
	Wend
End Sub

Sub Rotate()
    If (torqueDirection = 1) Then
        Call RotateClockwise()
    ElseIf (torqueDirection = -1) Then
        Call RotateCounterClockwise()
    Else
        ' The torqueDirection can be called outside this program, so must 
        ' anticipate what to to in this case.  Otherwise, the motor will 
        ' spin continuously until power is cut, or something else sets the 
        ' torqueDirection to a 1 or -1
        Call StopGently()
    End If
End Sub

Sub RotateClockwise()
    ' rotate CCW as viewed from flange face.
    MOVE.DIR = 1
    MOVE.GOVEL
End Sub

Sub RotateCounterClockwise()
    ' rotate CW as viewed from flange face.
    MOVE.DIR = 0
    MOVE.GOVEL
End Sub

Sub PrintCurrentUserParameterValues()
    Cls
    Print "* * * PARAMETERS AT:  " + STR$(DRV.TIME)
    Print "testInProces: " + STR$(testInProcess)
    Print "controllerInitialized: " + STR$(controllerInitialized)
    Print "currentTorque: " + STR$(currentTorque)
    Print "watchdogValue: " + STR$(watchdogValue)
    Print "ccwTorqueLimit: " + STR$(ccwTorqueLimit)
    Print "cwTorqueLimit: " + STR$(cwTorqueLimit)
    Print "runSpeed: " + STR$(runSpeed)
    Print "manualSpeed: " + STR$(manualSpeed)
End Sub

'-------------------------------------------------------
' Here is the actual logic for a single 
' loop through the test cycle.
'-------------------------------------------------------
Sub PerformSteeringShaftTestCycle()
    Call DebugMessageInteger("runSpeed = ", runSpeed)

    ' purpose of this is to not have to set it every time, 
    ' through this While loop, but also to allow manual mode 
    ' and automatic mode to use two different run speeds.
    'If (MOVE.RUNSPEED <> runSpeed) Then 
    '	MOVE.RUNSPEED = runSpeed
    'End If

    If (testInProcess = _FALSE) Then
        Call StopAndReturnToHome()
    End If

    ' here is the actual test, the -191147 is 15 degrees at the flange

    If (currentTorque < cwTorqueLimit And firstStageComplete = _FALSE And PL.FB > -191147) Then
        Call RotateClockwise()
    ElseIf (currentTorque > ccwTorqueLimit And secondStageComplete = _FALSE And PL.FB < 191147) Then
        firstStageComplete = _TRUE
        Call RotateCounterClockwise()
        Print "ROTATING CCW, currentTorque: " + STR$(currentTorque)
    Else
        Call StopAndReturnToHome()

        secondStageComplete = _TRUE
        testInProcess = _FALSE

    End If

    Call DebugMessageInteger("watchdogValue = ", watchdogValue)

    ' decrement the timer, if you have not heard from the 
    ' watchdog in a while, shut down the test because the 
    ' application is no longer providing updates of what 
    ' the applied torque is.
    watchdogValue = watchdogValue - 1

    Call DebugMessageInteger("watchdogValue = ", watchdogValue)

    ' see if motor needs to stop turning because 
    ' watchdog program is no longer making calls
    If (watchdogValue <= 0) Then

        ' set this so the next time through, the current 
        ' While loop will not be entered.
        testInProcess = _FALSE

        ' make the motor stop turning.
        Call StopGently()

        ' return to starting position of test, but test has still failed.
        MOVE.GOHOME
    End If
End Sub

'-------------------------------------------------------
' Here is the actual logic for a single 
' loop through the test cycle.
'-------------------------------------------------------
Sub PerformUnidirectionalTestCycle()
    ' must declare local variables first.
    Dim percentDifferenceFromLast As float

    ' for percent difference checking.
    previousTorque = currentTorque
    percentDifferenceFromLast = PctDiff()

    Call DebugMessageInteger("runSpeed = ", runSpeed)

    ' purpose of this is to not have to set it every time, 
    ' through this While loop, but also to allow manual mode 
    ' and automatic mode to use two different run speeds.
    If (MOVE.RUNSPEED <> runSpeed) Then
        MOVE.RUNSPEED = runSpeed
    End If

    If (TorqueReachedLimit() = _TRUE) Then
        Call StopAndReturnToHome()
        cancelled = _FALSE ' the user did not cancel it
        testInProcess = _FALSE
    Else
        ' here is the actual test
        If (TorqueReachedLimit() = _FALSE And percentDifferenceFromLast <= diffLimit) Then
            Call Rotate()
        Else
            Call DebugMessageString("percentDiff = " + STR$(percentDifferenceFromLast))
            Call StopGently()
            testInProcess = _FALSE
        End If

        ' decrement the timer, if you have not heard from the 
        ' watchdog in a while, shut down the test because the 
        ' application is no longer providing updates of what 
        ' the applied torque is.
        watchdogValue = watchdogValue - 1

        Call DebugMessageInteger("watchdogValue = ", watchdogValue)

        ' see if motor needs to stop turning because 
        ' watchdog program is no longer making calls
        If (watchdogValue <= 0) Then

            ' set this so the next time through, the current 
            ' While loop will not be entered.
            testInProcess = _FALSE

            ' make the motor stop turning.
            Call StopGently()

            ' return to starting position of test, but test has still failed.
            MOVE.GOHOME
        End If
    End If

End Sub

Function PctDiff() As float
    If (ABS(currentTorque) + ABS(previousTorque)) > 0 Then
        PctDiff = (ABS(currentTorque - previousTorque) / ((ABS(currentTorque) + ABS(previousTorque)) * 0.5)) * 100
    Else
        PctDiff = 0
    End If
End Function

Function TorqueReachedLimit() As Integer
    If (torqueDirection = 1) Then
        ' rotating CCW values increasing
        Print("Entering torqueDirection = 1")
        Print("Current torque = ") + STR$ (currentTorque)
		Print("Previous torque = ") + STR$ (previousTorque)
		Print("Clockwise torque limit = ") + STR$ (cwTorqueLimit)
		
		If (currentTorque > cwTorqueLimit) Then
            TorqueReachedLimit = _TRUE
        Else
            TorqueReachedLimit = _FALSE
        End If
    ElseIf (torqueDirection = -1) Then
        ' rotating CW values decreasing
        Print("Entering torqueDirection = -1")
        Print("Current torque = ") + STR$ (currentTorque)
		Print("Previous torque = ") + STR$ (previousTorque)
		Print("Clockwise torque limit = ") + STR$ (cwTorqueLimit)
		
		If (currentTorque < ccwTorqueLimit) Then
            TorqueReachedLimit = _TRUE
        Else
            TorqueReachedLimit = _FALSE
        End If
    Else
        ' The torqueDirection can be called outside this program, so must 
        ' anticipate what to to in this case. This will shut down the 
        ' test and is done for safety.
        TorqueReachedLimit = _TRUE
    End If
End Function

'-----------------------------------------
' Preconditions: User inputs have been validated
'-----------------------------------------
Sub PerformSingleManualCycle()
    ' purpose of this is to not have to set it every time, 
    ' through this While loop, but also to allow manual mode 
    ' and automatic mode to use two different run speeds.
    If (MOVE.RUNSPEED <> manualSpeed) Then
        MOVE.RUNSPEED = manualSpeed
    End If

    If (DIN4.STATE = 1) Then ' joystick up
        ' set direction to clockwise
        torqueDirection = -1
        Call Rotate()
    ElseIf (DIN7.STATE = 1) Then ' joystick down
        ' set direction to counter clockwise
        torqueDirection = 1
        Call Rotate()
    Else
        ' slow program execution down to not overwhelm the drive.
        Pause(0.2)

        ' 65538 occurs when the motion curve has completed, meaning 
        ' that the CCW or CW motion had reached constant speed and 
        ' is still active.
        If (DRV.MOTIONSTAT = 65538) Then
            Call StopGently()
        End If

    End If
End Sub

Function CanEnterManualMode() As Integer
    ' DIN3.STATE = 1 means the operation mode switch is on.
    ' watchdogValue > 0 means watchdog timer has not expired indicating the 
    '     computer and the software are still communicating with the VFD
    ' testInProcess = 0 means a test is not currently in process.

    If (DIN3.STATE = 1 And watchdogValue > 0 And testInProcess = _FALSE) Then
        CanEnterManualMode = _TRUE
    Else
        CanEnterManualMode = _FALSE
    End If
End Function

Function UserProvidedValidValues() As Integer
    ' here is where the validation takes place.  The values here should
    ' be consistent with the global variable comments for minimum and 
    ' maximum allowable values.

    ' The only valid values are 0 and 15.
    If (testInProcess <> _TRUE And testInProcess <> _FALSE) Then
        testInProcess = _FALSE
        UserProvidedValidValues = _FALSE
        Exit Function
    End If

    ' The only valid values are 0 and 15.
    If (controllerInitialized <> _TRUE And controllerInitialized <> _FALSE) Then
        controllerInitialized = _FALSE
        UserProvidedValidValues = _FALSE
        Exit Function
    End If

    ' this validates the allowable torque range of the torque cell, 
    ' other validations must occurr each test cycle to determine if 
    ' the CW or CCW limits of the test have been reached.
    If (currentTorque > 20000 Or currentTorque < -20000) Then

        ' stop immediately.
        Call StopGently()

        testInProcess = _FALSE
        UserProvidedValidValues = _FALSE
        Exit Function
    End If

    ' watchdog values protect the operator in the event 
    ' of watchdog application failure or lockup.
    If (watchdogValue < 10 Or watchdogValue > 250) Then
        watchdogValue = 250
        UserProvidedValidValues = _FALSE
        Exit Function
    End If

    ' The ccwTorqueLimit has the potential to destroy the test 
    ' specimen, and possibly the fixtures, so it's very important 
    ' to not set the value improperly.
    If (ccwTorqueLimit < -20000 Or cwTorqueLimit > 20000) Then
        ' stop immediately.
        Call StopGently()

        testInProcess = _FALSE
        UserProvidedValidValues = _FALSE
        Exit Function
    End If

    ' allowable run speed between 1 and 500, if the user tries to set 
    ' a value, just disallow it, don't worry about telling them.
    If (runSpeed < 1) Then
        runSpeed = 1
    ElseIf (runSpeed > 500) Then
        runSpeed = 500
    End If

    ' if you get here, it's valid
    UserProvidedValidValues = _TRUE
End Function

' Standardized debug messages with
' integer values needing to be displayed
Sub DebugMessageInteger(title As String, value As Integer)
    Print(title + STR$(value) + " (time = " + STR$(DRV.TIME) + ")")
End Sub

' Standardized debug messages
Sub DebugMessageString(value As String)
    Print(value + " (time = " + STR$(DRV.TIME) + ")")
End Sub

'-------------- Interrupt Routines -------------------
