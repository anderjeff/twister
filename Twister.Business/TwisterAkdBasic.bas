'-------------- Device Params -----------------------
Params 
	FB1.PIN = 100
	FB1.POUT = 20
	FB1.PUNIT = 0
	FB1.SELECT = -1
	FB2.PIN = 100
	FB2.POUT = 20
	FB2.PUNIT = 0
	FB3.PIN = 100
	FB3.POUT = 20
	FB3.PUNIT = 0
	UNIT.ACCLINEAR = 0
	UNIT.ACCROTARY = 0
	UNIT.LABEL = "cm" 
	UNIT.PIN = 1
	UNIT.PLINEAR = 0
	UNIT.POUT = 1
	UNIT.PROTARY = 4
	UNIT.VLINEAR = 0
	UNIT.VROTARY = 0' 0 = rpm, 1 = rps, 2 = deg/s, 3 = custom, 4= rad/s, I want 0 (RPM)
	AIN.CUTOFF = 5000.0
	AIN.DEADBAND = 0.000
	AIN.DEADBANDMODE = 0
	AIN.ISCALE = 0.001
	AIN.MODE = 1
	AIN.OFFSET = 0.000
	AIN.PSCALE = 0.000
	AIN.VSCALE = 0.06
	AOUT.DEBUGADDR = 4
	AOUT.DEBUGDATATYPE = 0
	AOUT.DEBUGSCALE = 1.0
	AOUT.ISCALE = 0.001
	AOUT.MODE = 0
	AOUT.OFFSET = 0.000
	AOUT.PSCALE = 0.000
	AOUT.VSCALE = 0.06
	CAP0.EDGE = 1
	CAP0.EN = 0
	CAP0.EVENT = 0
	CAP0.FILTER = 0
	CAP0.MODE = 0
	CAP0.PREEDGE = 1
	CAP0.PREFILTER = 0
	CAP0.PRESELECT = 0
	CAP0.TRIGGER = 0
	CAP1.EDGE = 1
	CAP1.EN = 0
	CAP1.EVENT = 0
	CAP1.FILTER = 0
	CAP1.MODE = 0
	CAP1.PREEDGE = 1
	CAP1.PREFILTER = 0
	CAP1.PRESELECT = 0
	CAP1.TRIGGER = 0
	CS.DEC = 10000.17
	CS.TO = 6
	CS.VTHRESH = 5.0
	DIN1.FILTER = 1
	DIN1.INV = 0
	DIN1.MODE = 0
	DIN2.FILTER = 1
	DIN2.INV = 0
	DIN2.MODE = 0
	DIN3.FILTER = 2
	DIN3.INV = 0
	DIN3.MODE = 0
	DIN4.FILTER = 2
	DIN4.INV = 0
	DIN4.MODE = 0
	DIN5.FILTER = 2
	DIN5.INV = 0
	DIN5.MODE = 0
	DIN6.FILTER = 2
	DIN6.INV = 0
	DIN6.MODE = 0
	DIN7.FILTER = 2
	DIN7.INV = 0
	DIN7.MODE = 0
	DIO10.DIR = 0
	DIO10.INV = 0
	DIO11.DIR = 0
	DIO11.INV = 0
	DIO9.DIR = 0
	DIO9.INV = 0
	DOUT.RELAYMODE = 0
	DOUT1.MODE = 0
	DOUT1.PARAM = 0.000
	DOUT2.MODE = 0
	DOUT2.PARAM = 0.000
	DRV.ACC = 10000.17
	
	' REQUIRED FOR MOVE.RUNSPEED IS DRV.OPMODE = 2 and 
	' DRV.CMDSOURCE = 5, SO THIS IS IMPORTANT!!
	DRV.CMDSOURCE = 5
	
	DRV.DBILIMIT = 1.0
	DRV.DEC = 10000.17
	DRV.DIR = 0
	DRV.DISTO = 1000
	DRV.EMUEDIR = 0
	DRV.EMUEMODE = 0
	DRV.EMUEMTURN = 0
	DRV.EMUERES = 0
	DRV.EMUEZOFFSET = 0
	DRV.HANDWHEELSRC = 2
	DRV.NAME = "AKD_VFD" 
	
	' REQUIRED FOR MOVE.RUNSPEED IS DRV.OPMODE = 2 and 
	' DRV.CMDSOURCE = 5, SO THIS IS IMPORTANT!!
	DRV.OPMODE = 2
	
	FAULT130.ACTION = 0
	FAULT131.ACTION = 0
	FAULT132.ACTION = 0
	FAULT134.ACTION = 0
	FAULT451.ACTION = 0
	FAULT702.ACTION = 0
	FB1.BISSBITS = 32
	FB1.INITSIGNED = 1
	FB1.OFFSET = 0
	FB1.ORIGIN = 0
	FB1.PDIR = 0
	FB1.POFFSET = 0
	FB1.POLES = 2
	FB1.PSCALE = 20
	FB2.DIR = 0
	FB2.ENCRES = 0
	FB2.MODE = 0
	FB2.POFFSET = 0
	FB2.SOURCE = 0
	FB3.MODE = 0
	FB3.PDIR = 0
	FB3.POFFSET = 0
	IL.FOLDWTHRESH = 0.000
	IL.KACCFF = 1.068
	IL.KP = 74.82
	IL.LIMITN = -17.999
	IL.LIMITP = 18.0
	IL.OFFSET = 0.000
	LOAD.INERTIA = 0.000
	MOTOR.BRAKEIMM = 0
	MOTOR.PHASE = 0
	MOTOR.PITCH = 32.0
	MOTOR.TBRAKETO = -1
	MOTOR.TEMPWARN = 0
	PL.ERRFTHRESH = 655360
	PL.ERRMODE = 0
	PL.ERRWTHRESH = 0
	PL.FBSOURCE = 0
	PL.INTINMAX = 61035
	PL.INTOUTMAX = 61035
	PL.KI = 0.000
	PL.KP = 66.824
	PL.MODP2 = 1048576
	PL.MODPDIR = 0
	PL.MODPEN = 0
	PLS.EN = 0
	PLS.MODE = 0
	PLS.P1 = 0
	PLS.P2 = 0
	PLS.P3 = 0
	PLS.P4 = 0
	PLS.P5 = 0
	PLS.P6 = 0
	PLS.P7 = 0
	PLS.P8 = 0
	PLS.T1 = 500
	PLS.T2 = 500
	PLS.T3 = 500
	PLS.T4 = 500
	PLS.T5 = 500
	PLS.T6 = 500
	PLS.T7 = 500
	PLS.T8 = 500
	PLS.UNITS = 0
	PLS.WIDTH1 = 0
	PLS.WIDTH2 = 0
	PLS.WIDTH3 = 0
	PLS.WIDTH4 = 0
	PLS.WIDTH5 = 0
	PLS.WIDTH6 = 0
	PLS.WIDTH7 = 0
	PLS.WIDTH8 = 0
	REGEN.REXT = 330
	REGEN.TEXT = 100.0
	REGEN.TYPE = 0
	REGEN.WATTEXT = 1000
	SWLS.EN = 0
	SWLS.LIMIT0 = 0
	SWLS.LIMIT1 = 1048576
	USER.INT1 = 0
	USER.INT2 = 0
	USER.INT3 = 0
	USER.INT4 = 0
	USER.INT5 = 0
	USER.INT6 = 0
	USER.INT7 = 0
	USER.INT8 = 0
	USER.INT9 = 0
	USER.INT10 = 0
	USER.INT11 = 0
	USER.INT12 = 0
	USER.INT13 = 0
	USER.INT14 = 0
	USER.INT15 = 0
	USER.INT16 = 0
	USER.INT17 = 0
	USER.INT18 = 0
	USER.INT19 = 0
	USER.INT20 = 0
	USER.INT21 = 0
	USER.INT22 = 0
	USER.INT23 = 0
	USER.INT24 = 0
	VBUS.OVWTHRESH = 0
	VBUS.UVFTHRESH = 380
	VBUS.UVMODE = 1
	VBUS.UVWTHRESH = 390
	VL.ARPF1 = 1689.781
	VL.ARPF2 = 500.0
	VL.ARPF3 = 1150.219
	VL.ARPF4 = 1150.219
	VL.ARPQ1 = 0.707
	VL.ARPQ2 = 0.5
	VL.ARPQ3 = 0.707
	VL.ARPQ4 = 0.707
	VL.ARTYPE1 = 5
	VL.ARTYPE2 = 5
	VL.ARTYPE3 = 5
	VL.ARTYPE4 = 5
	VL.ARZF1 = 2577.293
	VL.ARZF2 = 500.0
	VL.ARZF3 = 5000.0
	VL.ARZF4 = 5000.0
	VL.ARZQ1 = 0.707
	VL.ARZQ2 = 0.5
	VL.ARZQ3 = 0.707
	VL.ARZQ4 = 0.707
	VL.FBSOURCE = 0
	VL.GENMODE = 0
	VL.KBUSFF = 0.000
	VL.KI = 29.966
	VL.KP = 0.517
	VL.KVFF = 1.0
	VL.LIMITN = -2999.999
	VL.LIMITP = 3000.0
	VL.LMJR = 0.000
	VL.THRESH = 7219.166
	WS.DISTMAX = 2731
	WS.DISTMIN = 182
	WS.FREQ = 10.0
	WS.IMAX = 9.0
	WS.MODE = 0
	WS.NUMLOOPS = 5
	WS.T = 2
	WS.TDELAY1 = 5
	WS.TDELAY2 = 50
	WS.TDELAY3 = 100
	WS.VTHRESH = 100.0
End Params
'-------------- Define (dim) Global Variables --------

' all of these variables are mapped to user defined input 
' registers, allowing for shared data between this application
' (Fully Reversed Torsion Test.bas) and the watchdog application 
' (Twister 2015 is this case)

' An indicator as to if this test is in run mode or manual mode
' Two possible values:
'   Run mode ....... _TRUE
'   Manual mode .... _FALSE
Dim testInProcess As Integer 

' An indicator that the watchdog program has set the following parameters:
' cwTorque, ccwTorque, runSpeed, manualSpeed
' Two possible values:
'   Run mode ....... _TRUE
'   Manual mode .... _FALSE
Dim controllerInitialized As Integer 

' The most recent torque value provided by the watchdog application. 
' The values are in in-lbs and are used as values to start and stop 
' certain portions of the test.  SAFETY CRITICAL!! The test bench can 
' produce more torque than most tested components can handle.
' Range of possible values, based off the torque cell:
'   Minimum ...... -20,000 in-lbs
'   Maximum ...... 20,000 in-lbs
' The actual maximum values should be test dependant, for example, a 
' 1000 series steering shaft is tested to +/- 4,000 in-lbs
Dim currentTorque As Integer 

' This is a frequently updated value who's purpose is to make sure 
' communication is ongoing between this application and the the watchdog 
' application.  The watchdog application (Twister 2015) resets this value 
' each time it requests a rotational position value.  This application 
' subtracts 1 from this value each time through the running test portion
' the value every time it requests a rotational position value.   
' 
' Range of possible values are set by language, integer type is 32 bit 
'   signed integer in AKD Basic language.:
'   Minimum ...... -2147483648
'   Maximum ...... 2147483647

' In practice, the Int32 maximum value is much too high to be an effective 
' watchdog value.  250 has been tested to be a good value for near instant 
' response when the watchdog application crashes or hangs.
' Range of practical values:
'   Minimum ...... 10
'   Maximum ...... 250
Dim watchdogValue As Integer 

' This value is the maximimum torque value allowed in the couter-
' clockwise (CCW) direction. The counterclockwise direction when 
' looking normal to the torque cell flange face that connects to
' the test specimen (as opposed to the side connected to the 
' sliding carridge).
' Values in the CCW direction are interpreted as NEGATIVE, so 
' based off the maximum allowable torque cell torque, the limit 
' is -20,000 in-lbs.
Dim ccwTorqueLimit As Integer 

' This value is the maximimum torque value allowed in the 
' clockwise (CW) direction. The clockwise direction when 
' looking normal to the torque cell flange face that connects to
' the test specimen (as opposed to the side connected to the 
' sliding carridge).
' Values in the CW direction are interpreted as POSITIVE, so 
' based off the maximum allowable torque cell torque, the limit 
' is 20,000 in-lbs.
Dim cwTorqueLimit As Integer 

' This value is the maximum RPM that the electric motor should be 
' commanded to spin.  The gearbox has a 70:1 ratio, so for example 
' if the motor spins 700 rpm, the output speed to the flange of 
' the gearbox is 700 / 70 = 10 rpm, or 0.1667 rev/sec or 
' 0.1667 rev/sec * 360 deg/rev = 60 deg/s. This value will need 
' careful consideration during testing, but for now, keep the limits 
' very low, so the test is slow.
'
' Minimum Value = 10 (0.86 deg/s)
' Maximum Value = 500 (43 deg/s)
'
' A more accurate name for this variable could be motorRpm, I just 
' don't want to change it right now.
'
Dim runSpeed As Integer 

' Manual speed allows the operator to use the joystick to make 
' manual adjustments to the input shaft angle while they are installing the 
' test specimen into the test stand.  This adjustment should be very 
' fine and therefore the minimum and maximum values will not have the same
' allowance for ranges, at least until the operator usage proves otherwise.
'
' Minimum Value = 5 (0.43 deg/s)
' Maximum Value = 25 (2.14 deg/s)
'
Dim manualSpeed As Integer 

' This value sets the percent difference allowable between 2 consecutive
' readings from the torque cell before the part is considered to have failed
'
Dim diffLimit As Float 

' This value sets the direction for the application of torque.  Acceptable 
' values are 1 and -1, any other values should cause the test
' bench to stop moving.
'
'    Clockwise direction .......... -1
'    Counterclockwise direction ...  1
'
Dim torqueDirection As Integer 

' This is an ID number assigned to each type of test that is created.  Current (as of 1/15/2016)
' As more tests are added, increment values by +1
'
'   Steering Shaft Test (+/-4000 in-lbs) ...... 1
'   Unidirectional Test to Failure ............ 2
'
Dim testType As Integer 

' This value allows the operator to manually complete a test, in the case 
' where they want the data saved, but cannot rely on the automated test 
' checks to save the data.  It is meant to prevent lost test data.
'
'  True ..... _TRUE  (-1)
'  False .... _FALSE (0)
'
Dim operatorEndsTest As Integer 

' This value defines the total number of cycles that have been completed since 
' the last time it was reset.  Typically, resetting will be the responsibility 
' of the Modbus client.
'
Dim cycleCount As Integer 

' This is a flag to indicate that a calibration cycle should be performed.
'
' True ..... _TRUE  (-1)
' False .... _FALSE (0)
'
Dim isDueForCalibration as integer 

' The number of cycles that must be completed before a calibration 
' cycle must occur.
'
Dim calibrationInterval as integer 

' The angular position that the output flange will rotate to before 
' changing from the clockwise to counterclockwise direction when 
' running a fatigue test.
'
Dim clockwiseAngleLimit as long 

' The angular position that the output flange will rotate to before 
' changing from the counterclockwise to clockwise direction when 
' running a fatigue test.
'
Dim counterClockwiseAngleLimit as long 

' The value of torque in the clockwise direction recorded during 
' the last calibration cycle.  This value is persisted because the 
' servo drive performs the calibration internally and had access to 
' the torque value at the time the angle is set.
'
Dim cwTorqueLastCalibration as integer 

' The value of torque in the counterclockwise direction recorded during 
' the last calibration cycle. This value is persisted because the 
' servo drive performs the calibration internally and had access to 
' the torque value at the time the angle is set.
'
Dim ccwTorqueLastCalibration as integer 

' The number of cycles per second. This value is used for the fatigue 
' test and is used to set run speed after a calibration cycle has determined 
' the target cw and ccw angles.
'
Dim cyclesPerSecond as integer

' this section maps the variables to an input register 
' location where they can be written to and read from.
MBInfo 
	$MBMap32(5000, testInProcess)
	$MBMap32(5002, controllerInitialized)
	$MBMap32(5004, currentTorque)
	$MBMap32(5006, watchdogValue)
	$MBMap32(5008, ccwTorqueLimit)
	$MBMap32(5010, cwTorqueLimit)
	$MBMap32(5012, runSpeed)
	$MBMap32(5014, manualSpeed)
	$MBMapfloat(5016, diffLimit)
	$MBMap32(5018, torqueDirection)
	$MBMap32(5020, testType)
	$MBMap32(5022, operatorEndsTest)
	$MBMap32(5024, cycleCount)
	$MBMap32(5026, isDueForCalibration)
	$MBMap32(5028, calibrationInterval)
	$MBMap64(5030, clockwiseAngleLimit)' note this is a 64-bit value (needs 4 registers) and is used to hold PL.FB 
	$MBMap64(5034, counterClockwiseAngleLimit)' note this is a 64-bit (needs 4 registers) value and is used to hold PL.FB
	$MBMap32(5038, cwTorqueLastCalibration)' the torque value in the CW direction recorded during the last calibration cycle
	$MBMap32(5040, ccwTorqueLastCalibration)' the torque value in the CCW direction recorded during the last calibration cycle
	$MBMap32(5042, cyclesPerSecond) ' used for the fatigue test, lets the user specify the number of cycles per second, then the program can set run speed based off the angles in calibration cycle.
End 

' create boolean values, since it's not supported
' by the language. 
' TRUE IS NOT A VALID NAME, SO I CHOSE _TRUE
Const _TRUE = -1' this is all 1s for a signed integer (32 bit signed in this case)
Const _FALSE = 0

' the torque test has two stages, clockwise and counter clockwise.
' This value indicates whether of not the first stage of the 
' test has been complete.  
' Two possible values:
'   Yes it's complete ...... _TRUE
'   No, it's incomplete .... _FALSE
Dim firstStageComplete As Integer 

' This value indicates whether of not the second stage of the 
' test has been complete.  
' Two possible values:
'   Yes it's complete ...... _TRUE
'   No, it's incomplete .... _FALSE
Dim secondStageComplete As Integer 

' used as a loop counter, to show how many times 
' a certain loop has executed, for debugging mainly.
Dim cnt As Integer 

' used to solve the issue of having a cancelled test need 
' to stop and return to zero in the middle of a test cycle,
' usually when the user says so, or if a safety sensor 
' has been triggered.
Dim cancelled As Integer 

' The last torque reading that was recorded
Dim previousTorque As Integer 

'-------------- Main Program -------------------------
Main 
	
	' loop continuously
	While 1 = 1
		' for debugging, so I can see current values on console quickly.
		'Call PrintCurrentUserParameterValues
		
		' reset counter
		cnt = 0
		Call DebugMessageString(STR$ (controllerInitialized))
		
		' make sure everything is initialized before proceeding.
		While (controllerInitialized = _FALSE)
			print 
			' debugging message
			If (cnt = 1) Then 
				Call DebugMessageString("Waiting for controller to initialize.")
			ElseIf (cnt = 2) Then 
				Call DebugMessageString("Waiting for controller to initialize..")
			ElseIf (cnt = 3) Then 
				Call DebugMessageString("Waiting for controller to initialize...")
			Else 
				Call DebugMessageString("Waiting for controller to initialize")
			End If
			
			Call DebugMessageInteger("currentTorque: " , currentTorque)
			
			' slow the loop down just a bit, no need to 
			' check any faster than every 200 ms
			Pause (0.2)
			
			' increment counter
			cnt = cnt + 1
			If (cnt > 3) Then 
				cnt = 0
			End If
			
			' clear screen
			Cls 
			
			' quick fix to allow manual mode before the controller is initialized
			If (DIN3.STATE = 1 And testInProcess = _FALSE) Then 
				manualSpeed = 10
				Call DebugMessageString("Waiting for joystick to move.")
				Call PerformSingleManualCycle
			End If
		Wend
		
		' perform validation on the user inputs, it's for their own good. 
		' this should be done each time through because at any time the 
		' watchdog application can change the values in the register. It would 
		' not be safe to assume that the user has the knowledge or controls in 
		' place to make safe parameter decisions.
		If (UserProvidedValidValues = _TRUE And controllerInitialized = _TRUE) Then 
			Call RunTest
		End If
		
	wend
End Main

'-------------- Subroutines and Functions ------------
Sub RunTest
	If (testType = 1) Then 
		Call DebugMessageString("About to run Steering shaft test.")
		Call PerformSteeringShaftTest()
	ElseIf (testType = 2) Then 
		Call DebugMessageString("About to run Unidirectional test to failure.")
		Call PerformUnidirectionalTestToFailure()
	ElseIf (testType = 3) Then 
		Call DebugMessageString("About to run fatigue test.")
		Call PerformFatigueTest
	Else 
		Call PerformSingleManualCycle()
		'Exit Sub 
	End If
End Sub

'-------------------------------------------------------
' Here is the actual logic for a single 
' loop through the test cycle.
'-------------------------------------------------------
Sub PerformSteeringShaftTest
	' set the speed
	MOVE.RUNSPEED = runSpeed
	'MOVE.RUNSPEED = .1
	
	' The testInProcess indicates that the user wants to start the test, 
	' but the application has not yet reached the While loop below.  Once 
	' execution reaches the While loop, it will stay there until completed.
	If (testInProcess = _TRUE) Then 
		' perform test initialization
		firstStageComplete = _FALSE
		secondStageComplete = _FALSE
		
		' Home the current positon, so at the end of the test, 
		' we can return to this position
		MOVE.POSCOMMAND = 0
		
		' if the code reaches this point, the user has started a test, this 
		' allows the Else section to call StopAnReturnToHome once.  
		cancelled = _TRUE
		
		Call DebugMessageString("Checking if test in process.")
		While (testInProcess = _TRUE)
			Call PerformSteeringShaftTestCycle()
		Wend
	Else 
		Call DebugMessageString("Calling StopAnReturnToHome")
		If (cancelled = _TRUE) Then 
			Call StopAndReturnToHome()
			cancelled = _FALSE
		End If
		
		' test is not in process, so see if the user
		' wants to enter the manual mode, based on 
		' preset criteria.
		While (CanEnterManualMode() = _TRUE And testInProcess = _FALSE And controllerInitialized = _TRUE)
			Call DebugMessageString("Waiting for joystick to move.")
			Call PerformSingleManualCycle()
		Wend
	End If
End Sub

'-------------------------------------------------------
' Here is the actual logic for a single 
' loop through the test cycle.
'-------------------------------------------------------
Sub PerformUnidirectionalTestToFailure
	' set the speed
	MOVE.RUNSPEED = runSpeed
	
	' The testInProcess indicates that the user wants to start the test, 
	' but the application has not yet reached the While loop below.  Once 
	' execution reaches the While loop, it will stay there until completed.
	If (testInProcess = _TRUE) Then 
		' perform test initialization
		firstStageComplete = _FALSE
		secondStageComplete = _FALSE
		
		' Home the current positon, so at the end of the test, 
		' we can return to this position
		MOVE.POSCOMMAND = 0
		
		' if the code reaches this point, the user has started a test, this 
		' allows the Else section to call StopAnReturnToHome once.  
		cancelled = _TRUE
		
		Call DebugMessageString("Checking if test in process.")
		
		While (testInProcess = _TRUE)
			Call DebugMessageString("About to perform single run cycle.")
			Call PerformUnidirectionalTestCycle()
		Wend
		
	Else 
		Call DebugMessageString("Calling StopAnReturnToHome")
		If (cancelled = _TRUE) Then 
			Call StopGently()
			cancelled = _FALSE
		End If
		
		' test is not in process, so see if the user
		' wants to enter the manual mode, based on 
		' preset criteria.
		While (CanEnterManualMode() = _TRUE)
			Call DebugMessageString("Waiting for joystick to move.")
			Call PerformSingleManualCycle()
		Wend
	End If
End Sub

'-------------------------------------------------------
' Here is the actual logic for a fatigue test.
'-------------------------------------------------------
Sub PerformFatigueTest
	' set the speed
	MOVE.RUNSPEED = runSpeed
	
	' The testInProcess indicates that the user wants to start the test, 
	' but the application has not yet reached the While loop below.  Once 
	' execution reaches the While loop, it will stay there until completed.
	If (testInProcess = _TRUE) Then 
		' Home the current positon, so at the end of the test, 
		' we can return to this position
		Print "About to reset current position, PL.FB = " + STR$ (PL.FB )
		MOVE.POSCOMMAND = 0
		Print "Reset current position, PL.FB = " + STR$ (PL.FB )
		
		' if the code reaches this point, the user has started a test, this 
		' allows the Else section to call StopAnReturnToHome once.  
		cancelled = _TRUE
		
		Call DebugMessageString("Checking if test in process.")
		
		While (testInProcess = _TRUE)
			
			Call DebugMessageString("Checking if due for calibration.")
			
			If (isDueForCalibration = _TRUE) Then 
				Call PerformCalibration
			End If
			
			' -- run cycle
			Call PerformFatigueTestCycle
		Wend
	Else 
		Print "Fatigue test no longer in process." 
		If (cancelled = _TRUE) Then 
			Print "Test was cancelled, returning home." 
			Call StopAndReturnToHome
			cancelled = _FALSE
		End If
		
		' test is not in process, so see if the user
		' wants to enter the manual mode, based on 
		' preset criteria.
		While (CanEnterManualMode = _TRUE)
			Call DebugMessageString("Waiting for joystick to move.")
			Call PerformSingleManualCycle()
		Wend
	End If
End Sub


'-------------- Subroutines and Functions ------------

Sub StopGently
	' Do not call MOVE.ABORT, this  results in an abrupt stop and a 
	' clunking noise from gear backlash we think.
	MOVE.RUNSPEED = 0
	MOVE.GOVEL 
	MOVE.RUNSPEED = runSpeed
End Sub

Sub StopAndReturnToHome
	Call StopGently
	
	If (MOVE.RUNSPEED > 50) Then
		MOVE.RUNSPEED = 50
	End If
	
	' return to position established at the start of the test.
	MOVE.GOHOME 
	
	' let the test get back to zero before finishing.
	While (ABS (MOVE.POSCOMMAND ) > 0)
		Print "Returning home, PL.FB = " + STR$ (PL.FB ) + ", runSpeed = " + STR$ (runSpeed)
		Pause (0.1)
	Wend
	
	MOVE.RUNSPEED = runSpeed
End Sub

Sub Rotate
	If (torqueDirection = 1) Then 
		Call RotateClockwise
	ElseIf (torqueDirection = -1) Then 
		Call RotateCounterClockwise
	Else 
		' The torqueDirection can be called outside this program, so must 
		' anticipate what to to in this case.  Otherwise, the motor will 
		' spin continuously until power is cut, or something else sets the 
		' torqueDirection to a 1 or -1
		Call StopGently
	End If
End Sub

Sub RotateClockwise
	' rotate CCW as viewed from flange face.
	MOVE.DIR = 1
	MOVE.GOVEL 
End Sub

Sub RotateCounterClockwise
	' rotate CW as viewed from flange face.
	MOVE.DIR = 0
	MOVE.GOVEL 
End Sub

Sub PrintCurrentUserParameterValues
	Cls 
	Print "* * * PARAMETERS AT:  " + STR$ (DRV.TIME )
	Print "testInProces: " + STR$ (testInProcess)
	Print "controllerInitialized: " + STR$ (controllerInitialized)
	Print "currentTorque: " + STR$ (currentTorque)
	Print "watchdogValue: " + STR$ (watchdogValue)
	Print "ccwTorqueLimit: " + STR$ (ccwTorqueLimit)
	Print "cwTorqueLimit: " + STR$ (cwTorqueLimit)
	Print "runSpeed: " + STR$ (runSpeed)
	Print "manualSpeed: " + STR$ (manualSpeed)
End Sub

'-------------------------------------------------------
' Here is the actual logic for a single 
' loop through the test cycle.
'-------------------------------------------------------
Sub PerformSteeringShaftTestCycle
	Call DebugMessageInteger("runSpeed = " , runSpeed)
	
	' purpose of this is to not have to set it every time, 
	' through this While loop, but also to allow manual mode 
	' and automatic mode to use two different run speeds.
	'If (MOVE.RUNSPEED <> runSpeed) Then 
	'	MOVE.RUNSPEED = runSpeed
	'End If
	
	If (testInProcess = _FALSE) Then 
		Call StopAndReturnToHome
	End If
	
	' here is the actual test, the -191147 is 15 degrees at the flange
	
	If (currentTorque < cwTorqueLimit And firstStageComplete = _FALSE And PL.FB > -191147) Then 
		Call RotateClockwise
	ElseIf (currentTorque > ccwTorqueLimit And secondStageComplete = _FALSE And PL.FB < 191147) Then 
		firstStageComplete = _TRUE
		Call RotateCounterClockwise
		Print "ROTATING CCW, currentTorque: " + STR$ (currentTorque)
	Else 
		Call StopAndReturnToHome
		
		secondStageComplete = _TRUE
		testInProcess = _FALSE
		
	End If
	
	Call DebugMessageInteger("watchdogValue = " , watchdogValue)
	
	' decrement the timer, if you have not heard from the 
	' watchdog in a while, shut down the test because the 
	' application is no longer providing updates of what 
	' the applied torque is.
	watchdogValue = watchdogValue-1
	
	Call DebugMessageInteger("watchdogValue = " , watchdogValue)
	
	' see if motor needs to stop turning because 
	' watchdog program is no longer making calls
	If (watchdogValue <= 0) Then 
		
		' set this so the next time through, the current 
		' While loop will not be entered.
		testInProcess = _FALSE
		
		' make the motor stop turning.
		Call StopGently
		
		' return to starting position of test, but test has still failed.
		MOVE.GOHOME 
	End If
End Sub

'-------------------------------------------------------
' Here is the actual logic for a single 
' loop through the test cycle.
'-------------------------------------------------------
Sub PerformUnidirectionalTestCycle
	' must declare local variables first.
	Dim percentDifferenceFromLast As float 
	
	' for percent difference checking.
	previousTorque = currentTorque
	percentDifferenceFromLast = PctDiff()
	
	Call DebugMessageInteger("runSpeed = " , runSpeed)
	
	' purpose of this is to not have to set it every time, 
	' through this While loop, but also to allow manual mode 
	' and automatic mode to use two different run speeds.
	If (MOVE.RUNSPEED <> runSpeed) Then 
		MOVE.RUNSPEED = runSpeed
	End If
	
	If (TorqueReachedLimit() = _TRUE) Then 
		Call StopAndReturnToHome
		cancelled = _FALSE' the user did not cancel it
		testInProcess = _FALSE
	Else 
		' here is the actual test
		If (TorqueReachedLimit() = _FALSE And percentDifferenceFromLast <= diffLimit) Then 
			Call Rotate()
		Else 
			Call DebugMessageString("percentDiff = " + STR$ (percentDifferenceFromLast))
			Call StopGently()
			testInProcess = _FALSE
		End If
		
		' decrement the timer, if you have not heard from the 
		' watchdog in a while, shut down the test because the 
		' application is no longer providing updates of what 
		' the applied torque is.
		watchdogValue = watchdogValue-1
		
		Call DebugMessageInteger("watchdogValue = " , watchdogValue)
		
		' see if motor needs to stop turning because 
		' watchdog program is no longer making calls
		If (watchdogValue <= 0) Then 
			
			' set this so the next time through, the current 
			' While loop will not be entered.
			testInProcess = _FALSE
			
			' make the motor stop turning.
			Call StopGently
			
			' return to starting position of test, but test has still failed.
			MOVE.GOHOME 
		End If
	End If
	
End Sub

Sub PerformFatigueTestCycle
	Call DebugMessageInteger("Performing FatigueTestCycle with runSpeed = " , runSpeed)
	
	firstStageComplete = _FALSE
	secondStageComplete = _FALSE
	
	While (secondStageComplete = _FALSE AND testInProcess = _TRUE)
		' The -191147 and 191147 are 15 degrees in their respective directions, at the flange. 
		' The value must increase if more angle of twist is required, it is just there in order 
		' to stop the shaft from twisting excessively.
		If (PL.FB > clockwiseAngleLimit And firstStageComplete = _FALSE And PL.FB > -191147) Then 
			Call RotateClockwise
			Print "Performing fatigue test, ROTATING CW, PL.FB = " + STR$ (PL.FB ) + ", currentTorque: " + STR$ (currentTorque)
		ElseIf (PL.FB < counterClockwiseAngleLimit And secondStageComplete = _FALSE And PL.FB < 191147) Then 
			firstStageComplete = _TRUE
			Call RotateCounterClockwise
			Print "Performing fatigue test, ROTATING CCW, PL.FB = " + STR$ (PL.FB ) + ", currentTorque: " + STR$ (currentTorque)
		Else 
			secondStageComplete = _TRUE
			cycleCount = cycleCount + 1
		End If
		
		Call DebugMessageInteger("Checking watchdog timer, watchdogValue = " , watchdogValue)
		
		' decrement the timer, if you have not heard from the 
		' watchdog in a while, shut down the test because the 
		' application is no longer providing updates of what 
		' the applied torque is.
		watchdogValue = watchdogValue-1
		
		Call DebugMessageInteger("Decremented watchdog timer by 1, watchdogValue = " , watchdogValue)
		
		' see if motor needs to stop turning because 
		' watchdog program is no longer making calls
		If (watchdogValue <= 0) Then 
			
			' set this so the next time through, the current 
			' While loop will not be entered.
			testInProcess = _FALSE
			
			Call StopAndReturnToHome
		End If		
	Wend	
End Sub

Function PctDiff As float 
	If (ABS (currentTorque) + ABS (previousTorque)) > 0 Then 
		PctDiff = (ABS (currentTorque-previousTorque) / ((ABS (currentTorque) + ABS (previousTorque)) * 0.5)) * 100
	Else 
		PctDiff = 0
	End If
End Function

Function TorqueReachedLimit As Integer 
	If (torqueDirection = 1) Then 
		' rotating CCW values increasing
		Print ("Entering torqueDirection = 1")
		Print ("Current torque = ") + STR$ (currentTorque)
		Print ("Previous torque = ") + STR$ (previousTorque)
		Print ("Clockwise torque limit = ") + STR$ (cwTorqueLimit)
		
		If (currentTorque > cwTorqueLimit) Then 
			TorqueReachedLimit = _TRUE
		Else 
			TorqueReachedLimit = _FALSE
		End If
	ElseIf (torqueDirection = -1) Then 
		' rotating CW values decreasing
		Print ("Entering torqueDirection = -1")
		Print ("Current torque = ") + STR$ (currentTorque)
		Print ("Previous torque = ") + STR$ (previousTorque)
		Print ("Clockwise torque limit = ") + STR$ (cwTorqueLimit)
		
		If (currentTorque < ccwTorqueLimit) Then 
			TorqueReachedLimit = _TRUE
		Else 
			TorqueReachedLimit = _FALSE
		End If
	Else 
		' The torqueDirection can be called outside this program, so must 
		' anticipate what to to in this case. This will shut down the 
		' test and is done for safety.
		TorqueReachedLimit = _TRUE
	End If
End Function

'-----------------------------------------
' Preconditions: User inputs have been validated
'-----------------------------------------
Sub PerformSingleManualCycle
	' purpose of this is to not have to set it every time, 
	' through this While loop, but also to allow manual mode 
	' and automatic mode to use two different run speeds.
	If (MOVE.RUNSPEED <> manualSpeed) Then 
		MOVE.RUNSPEED = manualSpeed
	End If
	
	If (DIN4.STATE = 1) Then ' joystick up
	' set direction to clockwise
	torqueDirection = -1
	Call Rotate
ElseIf (DIN7.STATE = 1) Then ' joystick down
' set direction to counter clockwise
torqueDirection = 1
Call Rotate
Else 
	' slow program execution down to not overwhelm the drive.
	Pause (0.2)
	
	' 65538 occurs when the motion curve has completed, meaning 
	' that the CCW or CW motion had reached constant speed and 
	' is still active.
	If (DRV.MOTIONSTAT = 65538) Then 
		Call StopGently
	End If
	
End If
End Sub

Function CanEnterManualMode As Integer 
	' DIN3.STATE = 1 means the operation mode switch is on.
	' watchdogValue > 0 means watchdog timer has not expired indicating the 
	'     computer and the software are still communicating with the VFD
	' testInProcess = 0 means a test is not currently in process.
	
	If (DIN3.STATE = 1 And watchdogValue > 0 And testInProcess = _FALSE) Then 
		CanEnterManualMode = _TRUE
	Else 
		CanEnterManualMode = _FALSE
	End If
End Function

Function UserProvidedValidValues As Integer 
	' here is where the validation takes place.  The values here should
	' be consistent with the global variable comments for minimum and 
	' maximum allowable values.
	
	' The only valid values are 0 and 15.
	If (testInProcess <> _TRUE And testInProcess <> _FALSE) Then 
		testInProcess = _FALSE
		UserProvidedValidValues = _FALSE
		Exit Function 
	End If
	
	' The only valid values are 0 and 15.
	If (controllerInitialized <> _TRUE And controllerInitialized <> _FALSE) Then 
		controllerInitialized = _FALSE
		UserProvidedValidValues = _FALSE
		Exit Function 
	End If
	
	' this validates the allowable torque range of the torque cell, 
	' other validations must occurr each test cycle to determine if 
	' the CW or CCW limits of the test have been reached.
	If (currentTorque > 20000 Or currentTorque < -20000) Then 
		
		' stop immediately.
		Call StopGently
		
		testInProcess = _FALSE
		UserProvidedValidValues = _FALSE
		Exit Function 
	End If
	
	' watchdog values protect the operator in the event 
	' of watchdog application failure or lockup.
	If (watchdogValue < 10 Or watchdogValue > 250) Then 
		watchdogValue = 250
		UserProvidedValidValues = _FALSE
		Exit Function 
	End If
	
	' The ccwTorqueLimit has the potential to destroy the test 
	' specimen, and possibly the fixtures, so it's very important 
	' to not set the value improperly.
	If (ccwTorqueLimit < -20000 Or cwTorqueLimit > 20000) Then 
		' stop immediately.
		Call StopGently
		
		testInProcess = _FALSE
		UserProvidedValidValues = _FALSE
		Exit Function 
	End If
	
	' allowable run speed between 1 and 500, if the user tries to set 
	' a value, just disallow it, don't worry about telling them.
	If (runSpeed < 1) Then 
		runSpeed = 1
	ElseIf (runSpeed > 1000) Then 
		runSpeed = 1000
	End If
	
	' if you get here, it's valid
	UserProvidedValidValues = _TRUE
End Function

Sub PerformCalibration
	' slow run speed and return to zero.
	Call StopAndReturnToHome
	
	' set the runspeed.
	MOVE.RUNSPEED = 100
	
	firstStageComplete = _FALSE
	secondStageComplete = _FALSE
	
	' run this loop until the calibration is complete.
	While (isDueForCalibration = _TRUE)
		If (currentTorque < cwTorqueLimit And firstStageComplete = _FALSE And PL.FB > -191147) Then 
			Call RotateClockwise
			clockwiseAngleLimit = PL.FB 
			cwTorqueLastCalibration = currentTorque
			Print "Performing calibration, ROTATING CW...PL.FB = " + STR$ (clockwiseAngleLimit) + " currentTorque = " + STR$ (cwTorqueLastCalibration)
			Print "currentTorque = " + STR$ (currentTorque) + ", cwTorqueLimit = " + STR$ (cwTorqueLimit) + ", ccwTorqueLimit = " + STR$ (ccwTorqueLimit)
		ElseIf (currentTorque > ccwTorqueLimit And secondStageComplete = _FALSE And PL.FB < 191147) Then 
			firstStageComplete = _TRUE
			Call RotateCounterClockwise
			counterClockwiseAngleLimit = PL.FB 
			ccwTorqueLastCalibration = currentTorque
			Print "Performing calibration, ROTATING CCW... PL.FB = " + STR$ (counterClockwiseAngleLimit) + " currentTorque = " + STR$ (ccwTorqueLastCalibration)
			Print "currentTorque = " + STR$ (currentTorque) + ", cwTorqueLimit = " + STR$ (cwTorqueLimit) + ", ccwTorqueLimit = " + STR$ (ccwTorqueLimit)
		Else 
			secondStageComplete = _TRUE
			isDueForCalibration = _FALSE
			Call CalculateRunSpeed
			
			Call StopAndReturnToHome
		End If
	Wend
	
	' reset the run speed to the user specified value.
	MOVE.RUNSPEED = runSpeed
End Sub

Sub CalculateRunSpeed
	' determine how far we have to travel each cycle
	Dim distance = ABS(ccwTorqueLastCalibration - cwTorqueLastCalibration)
	
End Sub

' Standardized debug messages with
' integer values needing to be displayed
Sub DebugMessageInteger(title As String , value As Integer)
	Print (title + STR$ (value) + " (time = " + STR$ (DRV.TIME ) + ")")
End Sub

' Standardized debug messages
Sub DebugMessageString(value As String)
	Print (value + " (time = " + STR$ (DRV.TIME ) + ")")
End Sub

'-------------- Interrupt Routines -------------------
